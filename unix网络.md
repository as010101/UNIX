tcpdump直接与数据链路进行通信 其他的都是socket或者XTI<br>

UDP有自己的长度，传输过程中将随数据一道传递给接收端应用进程<br>
UDP 不保证最后能到达最终目的地 不保证每个数据报只到达一次 不保证每个数据报跨网后顺序保持一致<br>
udp是无连接的，一个客户udp产生一个socket，发送一个udp报给一个服务端，随后可用同一socket发送给另一服务端，同样地，一个udp服务端可用同一个udpsocket
接受来自多个多个客户端数据<br>

tcp面向连接的，即传数据之前要先有两个socket确认连接<br>
tcp是可靠的，发送数据会要求对方给到确认，除非数次请求失败tcp才放弃<br>
tcp含有动态估算数据传输在客户端和服务器的往返时间的算法(RTT)，以便于知道它要等待多长时间<br>
tcp的发送接收端会对数据数据排序（数据有序列号），并且有权利判定重复的数据报放弃<br>
tcp提供流量控制（flow control）<br>

udp与tcp都是全双工的<br>


tcp的三次握手<br>
服务器必须准备好接受外来的连接（socket bind listen accept）(passive open) <br>
客户端通过调用cnnect来主动连接(active open),这导致客户TCP发送-一个SYN (同
步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分
节不携带数据，其所在IP数据报只含有一个IP首部、-一个TCP首部及可能有的TCP选项。<br>
服务器必须确认(ACK)客户的SYN,同时自己也得发送一个SYN分节，它含有服务
器将在同一连接中发送的数据的`初始序列号`。服务器在单个分节中发送SYN和对客户SYN的
ACK (确认)。<br>


SYN (J)  -- SYN (K)  ACK(J+1)   -- ACK(K+1)  <br> 

tcp的终止<br>
1.某个应用程序首先调用close(主动关闭端（active close）),该端tcp发送FIN分节<br>
2.对端接受到该分节后，返回ACK分节<br>
3.一段时间后，对端执行结束，调用close，此时改该端tcp会发送FIN分节给另一端<br>
4.对端收到后发送ACK分节<br>
FIN(M)--ACK(M+1)--FIN(N)-ACK(N+1)<br>

在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的。这称
为半关闭(half-close)， 我们将在6.6节随shutdown函数再详细介绍。<br>
当套接字被关闭时，其所在端TCP各自发送了-一个FIN。我们在图中指出，这是由应用进程
调用close而发生的，不过需认识到，当一个Unix进 程无论自愿地(调用exi t或从main函数返
回)还是非自愿地(收到一个终止本进程的信号)终止时，所有打开的描述符都被关闭，这也
导致仍然打开的任何TCP连接上也发出- 一个FIN。<br>

路由循环 产生迷途的重复分组(lost duplicate)<br>
TIME_ WAIT状态有两个存在的理由:<br>
(1)可靠地实现TCP全双工连接的终止;<br>
(2)允许老的重复分节在网络中消逝。<br>



SYN Cookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接



子网掩码就是判断两个IP地址，是不是在同一个网段(或称子网)，在同一网段的两个地址，可以直接通信。不管是通过IP地址也好，还是通过“计算机名”，都是可以的。

如果两个IP地址，不在同一网段，这时候，要想通过IP地址访问另一网段的计算机(也是IP地址)，就需要网关地址。
网关地址就是出口的地址，而且，网关地址，是你最近的一个出口的地址。网关地址总是与你的计算机的IP地址是同一网段的。

如果两台计算机，不在同一网段，如果想使用计算机名(就是类似于compute1、cp2之类的名称，称为NetBIOS名称)，这时候，必须要使用WINS服务器来解析(或者手动编辑本机的hosts文件)，这就是WINS服务器的作用。


ping自己网关时，ping不通，如果网关没问题，就是自己ip有问题，可以修改ip地址（保证与网关同一网段，如何保证，通过子网掩码判断
，子网掩码与ip地址可得一网段，与网关得一网段，如相同，则是同一网段（mask得到的相同网段已经包含子网号了）,只是要注意的是
b类网址，管理员喜欢把除网络号的前八位作为子网号，在源ip寻址时，要注意是否是同一子网，详见tcp/ip 1 32page）


192.168.4.74  ip   11000000.10101000.0 0000100   A

255.255.128.0  mask   11111111.11111111.10000000.00000000 B

192.168.100.200  gateway  11000000.10101000.0 1100100  C

A&C B&C 得到的是同值
这一类是 mask 配c类ip地址 c类网关
如果是b类ip地址和b类网关，中间应该还有子网在主机和网段之间

如主机地址 140.252.1.1 mask=255.255.255.0

采用自然的划分方法，即把B类地址中留给主机的16 bit中的前8 bit作为子网  后8位作为主机号









